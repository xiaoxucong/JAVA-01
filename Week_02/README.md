学习笔记
堆内存 并不是越大越好
 小的话内存不足 导致崩溃
 堆大的话 垃圾回收时暂停时间过长  影响吞吐量



jvm 
# 回收算法  #
分为以下几类
## 1、引用计数法 ##
	主要的缺点是无法处理循环引用；在每次引用的产生和消除的时候，会伴随着一个加法或者减法的操作，对性能有一定的影响
## 2、标记-清除算法 ##
	根据可达性算法,把不可达的对象标记以下,进行回收,缺点是内存碎片化

## 3、标记-复制-清除算法 ##
	根据可达性算法,把不可达的对象标记以下,进行回收,回收后把未回收的对象复制到预留的位置 然后把该区域清空,缺点是内存利用率低 需要预留一块空间作为复制使用


## 4、标记-清除-压缩算法 ##
	清理垃圾后,移动对象到一边 ,缺点 需要重新引用

## 5、分代收集算法 ##
	是现在的jvm采用的算法,
	根据对象的存活周期的不同而将内存分为几块，分别为新生代、老年代和元数据
		新生代：朝生夕灭的对象（例如：方法的局部变量引用的对象等）。一般使用 标记-复制-清除算法
        老年代：存活得比较久，但还是要死的对象（例如：缓存对象、单例对象等）。一般使用 标记-清除-压缩算法
        永久代：对象生成后几乎不灭的对象（例如：加载过的类信息）一般使用 标记-清除-压缩算法
#  GC #
	回收分为以下几类
	1、串行：垃圾回收器 (Serial GC)
		只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）
		使用方法：-XX:+UseSerialGC  串联收集


	2、串行：ParNew收集器
		其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩
		使用方法：-XX:+UseParNewGC  ParNew收集器
	3、并行：Parallel收集器
			类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩

	4、并行：Parallel Old 收集器
			并行：Parallel收集器的老年代版本，使用多线程和“标记－整理”算法

	5、并发标记扫描CMS收集器
		CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：
			初始标记（CMS initial mark）
			并发标记（CMS concurrent mark）
			重新标记（CMS remark）
			并发清除（CMS concurrent sweep）
		其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
		由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）

		优点:并发收集、低停顿
		缺点：产生大量空间碎片、并发阶段会降低吞吐量
		注意：默认是并发标记收集器，当失败后，就会使用 老年代的 Serial Old 垃圾回收器。
		-XX:+UseConcMarkSweepGC  使用CMS收集器

		-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
		-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理
		-XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量） 
	6、G1收集器
		与CMS收集器相比G1收集器有以下特点：
			(1). 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。
			(2). 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。
		上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。
		G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。
		收集步骤：
			1)、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)
			2)、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。
			3)、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。
			4)、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。
		
			5)、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。
			6)、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。唯一和串行垃圾回收器不同的是，并行垃圾回收器是使用多线程来进行垃圾回收工作的。


## 串行GC   ##

	设置参数为 java -XX:+UseSerialGC -Xms512m -Xmx512m   -XX:+PrintGCDetails -XX:+PrintGCDateStamps 





## 并行GC ##
	设置参数为 java -XX:+UseParallelGC -Xms512m -Xmx512m   -XX:+PrintGCDetails -XX:+PrintGCDateStamps 

 

## CMS GC  ##
	设置参数为 java -XX:+UseConcMarkSweepGC -Xms512m -Xmx512m   -XX:+PrintGCDetails -XX+PrintGCDateStamps

## G1 GC  ##
	设置参数为 java -XX:+UseG1GC -Xms512m -Xmx512m   -XX:+PrintGCDetails -XX:+PrintGCDateStamps  

### 堆内存设置比较大时 ###
	基本都是Young GC,而且回收时程序暂停时间会比较长  


### 堆内存设置比较小时 ###
	后期都是full GC ,但是 回收的空间越来越小 最后内存溢出 





